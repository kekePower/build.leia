#!/bin/zsh

SCRIPT_VERSION="1.99.1-alpha"

if [[ $( grep REMOVEME ${0:a:h}/etc/${0:t}.conf ) ]]; then
    echo "Please edit the configuration file located at"
    echo "${0:a:h}/etc/${0:t}.conf"
    echo "Script aborted."
    exit
fi

# We load the configuration file
. ${0:a:h}/etc/${0:t}.conf

# This function is used to include common sets of files used
# Edit the path to reflect your installation
function include () {
  INC_FILE=${INCLUDEDIR}/${1}.inc
	if [[ ! -f ${INC_FILE} ]]; then
		INC_OPT=$( echo ${1} | cut -d\/ -f2 )
		echo "Supplied option \"${INC_OPT}\" is not valid."
		echo "Ignoring"
	else
		. ${INC_FILE}
	fi
}

include common/colors
include common/numcpu
include common/input_to_array

# Function: LOGGER
# This has to be included after the config file as this contains the path to
# the log file use by loggy
# Usage: loggy <message>
include common/loggy

# We try to find the system language and include it in the script.
# If we don't have the translation for the supplied language, the
# script will ask if the user wants to use en_US for now.
# It is also suggested that the user may want to help out by
# translating this script to their language.
SysLang=$( echo ${LANG} | cut -d= -f2 | cut -d. -f1 | sort -u )

if [[ -f ${INCLUDEDIR}/${0:t}/language/${MyLANG}.inc ]]; then
    include ${0:t}/language/${MyLANG} ${0:t}
    NOLANG=${SysLang}
elif [[ -f ${INCLUDEDIR}/${0:t}/language/${SysLang}.inc ]]; then
    include ${0:t}/language/${SysLang} ${0:t}
    NOLANG=${MyLANG}
else
    echo "\n${RED}Could not find a language file for your system language (${NOLANG}).${END}"
    echo "${WHITE}Would you like to continue with English (en_US)? (Y/n)${END} \c"
    read LangAnswer
    if [[ ( ${LangAnswer} == "" || ${LangAnswer} == "Y" || ${LangAnswer} == "y" ) ]]; then
        include ${0:t}/language/en_US ${0:t}
    else
        echo "\n${YELLOW}You decided not to continue. Sorry about that!${END}"
        echo "${WHITE}Please consider translating this script to your language.${END}"
        echo "${WHITE}The language files can be found at"
        echo "${INCLUDEDIR}/${0:t}/language/${END}.\n"
        exit
    fi
fi

function ShowHelp () {
	# Usage: ShowHelp ${0:t}
    for i in {10..29}
    do
        help=Help_${i}
        eval echo \$${help}
    done
	exit
}

# We set all the variables used to false
ADDONS_IS_SET=false
CLEAN_IS_SET=false
DIRTY_IS_SET=false
FORCE_IS_SET=false
NOGIT_IS_SET=false
FRESH_INSTALL=false

# Show the help information and exit
if [[ ${1} == "--help" ]]; then
	ShowHelp ${0:t}
	exit
fi

VKODI=Leia

# Edit this to install to another directory
PREFIX="/opt/${VKODI:l}"
#

KODI=${KODIDIR}/${VKODI}
ARROW="${W}-${END}${INFO}>${END}"

MSG="Welcome to ${0:t} v${SCRIPT_VERSION}"
echo "${WHITE}[$(date +%T)]${END} ${W}${MSG}${END}"
loggy ${MSG}

# The default behavior is to do a clean,addons install
# Same as build.leia --with=clean,addons
if [[ ! ${@} ]]; then
	MSG="${L_100} --with=clean,addons"
	echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
	include ${0:t}/clean
	include ${0:t}/addons
elif [[ ${@} =~ "--with" ]]; then

  # Initialze the array in the function InputToArray before use
  # Options are: --with=clean,dirty,addons,no-git,force
  InputToArray ${@}
  for i in ${InputArray}
  do
    include ${0:t}/${i}
  done

  # We default to doing a dirty install if not --with=clean is set and if --with=dirty is not set
  # This will decrease build times
	if ! ${CLEAN_IS_SET} || ! ${DIRTY_IS_SET} ; then
		MSG="${L_100} --with=dirty"
		echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		include ${0:t}/dirty
	fi

fi

# We check to see if clean and dirty are set at the same time.
# This is not wanted and the script will exit if found.
if ${CLEAN_IS_SET} && ${DIRTY_IS_SET} ; then
	echo "${W}**${END} ${RED}${L_101}${END} ${W}**${END}"
	echo "${W}**${END} ${RED}${L_102} \"${0:t} --help\" ${L_103}${END} \t${W}**${END}"
	echo "${W}**${END} ${RED}${L_25}${END} \t\t\t\t\t\t\t${W}**${END}"
	exit
fi

# This will check if ccache is installed
# If it isn't, it will ask if you want to download from source, build and install it
# Since we're building Kodi v18 Leia, we're also using the latest ccache from Github
function build_ccache () {

	if [[ ! $( which ccache ) ]]; then
		MSG="${L_114}"
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${MSG}${END}"
		loggy ${MSG}
		MSG="${L_115}"
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${MSG}${END}"
		loggy ${MSG}
		MSG="Do you wish to download and install ccache from source? ${L_81} \c"
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${MSG}${END}"
		read installccache
		
		if [[ ${installccache} == "" || ${installccache} == "${L_82}" || ${installccache} == "${L_83}" ]]; then
			
			# First we load the config information
			include depends/ccache
			
			#Then we check if the depends directory exists, create it if not
			if [[ ! -d ${KODIDIR}/depends ]]; then
				mkdir ${KODIDIR}/depends
			else
				if [[ ! -d ${KODIDIR}/depends/${APP} ]]; then
					MSG="Fetching the ${APP} source from ${SOURCE}"
					echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${MSG}${END}"
					loggy ${MSG}
					builtin cd ${KODIDIR}/depends
					git clone -b master ${SOURCE} ${APP} >> ${LOGGYLOGFILE} 2>&1
					
					MSG="Compiling and installing ${APP}"
					builtin cd ${KODIDIR}/depends/${APP}
					${PRERUN} >> ${LOGGYLOGFILE} 2>&1
					if [[ -f ${CONFIGURE} ]]; then
						${CONFIGURE} --prefix=${APP_PREFIX} >> ${LOGGYLOGFILE} 2>&1
					else
						MSG="Something failed. Please check the log file: ${LOGGYLOGFILE}"
						echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${RED}${MSG}${END}"
					fi
					make -s -j${NUMCPU} >> ${LOGGYLOGFILE} 2>&1
					sudo make -s -j${NUMCPU} install >> ${LOGGYLOGFILE} 2>&1
					
					builtin cd ${HOME}
					if [[ $( which ccache ) ]]; then
						MSG="${APP} successfully installed and ready to use."
						echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${MSG}${END}"
					else
						MSG="${APP} was not installed. Check the logfile."
						echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${RED}${MSG}${END}"
					fi
				fi
			fi
		else
			MSG="You chose not to install ${APP}."
			echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${MSG}${END}"
		fi
	fi
	
}

# Function: FETCH_KODI
function fetch_kodi () {
	if [[ ! -d ${KODI} ]]; then
		MSG="${L_104} ${L_81}"
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${MSG}${END} \c"
		read answer
		
		if [[ ${answer} == "" || ${answer} == "${L_82}" || ${answer} == "${L_83}" ]]; then
			builtin cd ${KODIDIR} > /dev/null 2>&1
			MSG=${L_112}
			echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			git clone -b master https://github.com/xbmc/xbmc ${VKODI} >> ${LOGGYLOGFILE} 2>&1
			
			# We need to set a variable here so that we know it's a fresh copy
			FRESH_INSTALL=true
			
			MSG="${L_105} ${L_81}"
			echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${MSG}${END} \c"
			read binaryaddons
			
			if [[ ${binaryaddons} == "" || ${binaryaddons} == "${L_82}" || ${binaryaddons} == "${L_83}" ]]; then
				ADDONS_IS_SET=true
			else
				MSG="${L_106}"
				echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${MSG}${END}"
				ADDONS_IS_SET=false
			fi
		else
			echo "\n ${ARROW} ${YELLOW}${L_107} ${KODI}${END}"
			echo "${ARROW} ${YELLOW}git clone https://github.com/xbmc/xbmc ${VKODI}${END}"
			echo "${ARROW} ${WARNING}${L_25}${END}"
			exit
		fi
	fi
}

# Function: GIT_PULL
function git_pull () {
if ! ${FRESH_INSTALL} ; then
	
  if ${FORCE_IS_SET} ; then
      local YesForce
      YesForce=" (${L_24})"
  fi
	
	MSG="${L_20} ${VKODI}${YesForce}"
	echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
    
  if ! ${NOGIT_IS_SET} ; then
		MSG="${L_21} ${VKODI} ${L_22}"
		echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}

		builtin cd ${KODI}/kodi-build
	  git pull > /tmp/build.leia.gitpull 2>&1
  
	    if [[ $( grep "Already up-to-date" /tmp/build.leia.gitpull ) ]]; then
				if ${FORCE_IS_SET} ; then
					FORCED="${L_24}"
				else
					FORCED="${L_25}"
				fi
	
		    MSG="${VKODI} ${L_23} ${FORCED}"
				echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
				loggy ${MSG}
				GITMSG="${VKODI} ${L_108}"
  
				if ! ${FORCE_IS_SET} ; then
		      GITMSG="${VKODI} ${L_109}"
					exit
				fi
			fi
	fi

	# Removing the temp git pull file
	loggy "##############################################################"
	cat /tmp/build.leia.gitpull >> ${LOGGYLOGFILE} > /dev/null 2>&1
	rm -f /tmp/build.leia.gitpull > /dev/null 2>&1

fi
}

# Function: CLEAN_KODI
function clean_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if [[ ! ${GITMSG} ]]; then
  
	if ! ${FRESH_INSTALL} ; then
		if ${CLEAN_IS_SET} ; then
			MSG="${L_113}"
			echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			builtin cd ${KODI}
			rm -rf kodi-build > /dev/null 2>&1
			mkdir kodi-build > /dev/null 2>&1
			if [[ $( which ccache ) ]]; then
				echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_118}${END}"
				echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_119}${END}"
				echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_117} ${L_81}${END} \c"
				read emptyccache
				if [[ ${emptyccache} == "" || ${emptyccache} == "${L_82}" || ${emptyccache} == "${L_83}" ]]; then
					MSG="${L_116}"
					echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${MSG}${END}"
					loggy ${MSG}
					ccache -C >> ${LOGGYLOGFILE} 2>&1
				fi
			fi
		elif ${DIRTY_IS_SET} ; then
			builtin cd ${KODI}/kodi-build
		fi
	else
		if [[ $( which ccache ) ]]; then
			echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_118}${END}"
      echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_119}${END}"
			echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_117} ${L_81}${END} \c"
			read emptyccache
			if [[ ${emptyccache} == "" || ${emptyccache} == "${L_82}" || ${emptyccache} == "${L_83}" ]]; then
				MSG="${L_116}"
				echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${MSG}${END}"
				loggy ${MSG}
				ccache -C >> ${LOGGYLOGFILE} 2>&1
			fi
		fi
	fi
# End of the GITMSG check
fi

}

# Function: CONFIGURE_KODI
function configure_kodi () {
	
	# Run function build_ccache
	build_ccache

		if ${FRESH_INSTALL} ; then
			MSG="${L_31} ${VKODI} ${L_37}"
			echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			builtin cd ${KODI}
			mkdir kodi-build > /dev/null 2>&1
      builtin cd ${KODI}/kodi-build
      cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} >> ${LOGGYLOGFILE} 2>&1
			loggy "###########################################################"
		else
			if ${CLEAN_IS_SET} ; then
				MSG="${L_31} ${VKODI} ${L_38}"
				echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
				loggy ${MSG}
				builtin cd ${KODI}/kodi-build
				cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} >> ${LOGGYLOGFILE} 2>&1
			elif ${DIRTY_IS_SET} ; then
				MSG="${L_20} ${VKODI} ${L_39}"
				echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
				loggy ${MSG}
				builtin cd ${KODI}/kodi-build
			fi
		fi

}

# Function: BUILD_KODI
function build_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if [[ ! ${GITMSG} ]]; then

    MSG="${L_30} ${VKODI}"
    loggy ${MSG}
		
    MSG="${L_33} ${VKODI}. ${L_34}"
    echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
    loggy ${MSG}
    cmake --build . -- VERBOSE=0 -s -j${NUMCPU} >> ${LOGGYLOGFILE} 2>&1

    if [[ ! -f ${KODI}/kodi-build/kodi.bin ]]; then
        MSG="${L_35} ${VKODI} ${L_36}"
        echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
        loggy ${MSG}
				FAILED="${L_110} ${VKODI} ${L_111}"
    fi

# End of the GITMSG check
fi

}

# Function: INSTALL_KODI
function install_kodi () {

  if [[ ! ${FAILED} ]]; then
        MSG="${L_90} ${PREFIX}"
        echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
        loggy ${MSG}
        builtin cd ${KODI}/kodi-build
        sudo make -s install -j${NUMCPU} >> ${LOGGYLOGFILE} 2>&1
	loggy "#########################################################"
  fi

}

# Function: INSTALL_ADDONS
function install_addons () {
	if ${ADDONS_IS_SET} ; then
		if [[ ! ${FAILED} ]]; then
			if ${CLEAN_IS_SET} ; then
		    MSG="${L_91}"
		    echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		    loggy ${MSG}
				builtin cd ${KODI}
		    sudo make -s -C \
				tools/depends/target/binary-addons \
				distclean \
				> /dev/null 2>&1
			fi

		    MSG="${L_92}"
		    echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		    loggy ${MSG}
		    sudo make -s -j${NUMCPU} -C \
		    tools/depends/target/binary-addons \
		    PREFIX=${PREFIX} \
		    >> ${LOGGYLOGFILE} 2>&1
				NOTBUILT=$( grep "Following Addons failed to build" ${LOGGYLOGFILE} | cut -d: -f2 )
				if [[ ! ${NOTBUILT} == "" ]]; then
					MSG="${L_94}:${NOTBUILT}"
					echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${RED}${MSG}${END}"
				fi
		fi
	else
		MSG="${L_93}"
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${MSG}${END}"
		loggy ${MSG}
	fi
}

# Here we run all of our functions in turn
fetch_kodi
git_pull
clean_kodi
configure_kodi
build_kodi
install_kodi
install_addons

echo "###################################################################" >> ${LOGGYLOGFILE}
echo "#             End of compilation for ${VKODI}                         #" >> ${LOGGYLOGFILE}
echo "###################################################################" >> ${LOGGYLOGFILE}
echo "${WHITE}[$(date +%T)]${END} ${YELLOW}${L_120}: ${PREFIX}/bin/kodi${END}"
echo "${WHITE}[$(date +%T)]${END} ${YELLOW}${L_121}: ${LOGGYLOGFILE}${END}"