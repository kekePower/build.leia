#!/bin/zsh

SCRIPT_VERSION="1.2.2"

if [[ $( grep REMOVEME ${0:a:h}/etc/${0:t}.conf ) ]]; then
    echo "Please edit the configuration file located at"
    echo "${0:a:h}/etc/${0:t}.conf"
    echo "Script aborted."
    exit
fi
    
# This function is used to include common sets of files used
# Edit the path to reflect your installation
function include () {
  INC_FILE=${HOME}/bin/include/${1}.inc
	# echo ${INC_FILE}
	# exit
	if [[ ! -f ${INC_FILE} ]]; then
		INC_OPT=$( echo ${1} | cut -d\/ -f2 )
		echo "Supplied option \"${INC_OPT}\" is not valid."
		echo "Not critical. Will continue."
	else
		. ${INC_FILE}
	fi
}

include common/colors
include common/numcpu
include common/with_to_array

# We load the configuration file
. ${0:a:h}/etc/${0:t}.conf

# Function: LOGGER
# Usage: loggy <message>
include common/loggy

# We try to find the system language and include it in the script.
# If we don't have the translation for the supplied language, the
# script will ask if the user wants to use en_US for now.
# It is also suggested that the user may want to help out by
# translating this script to their language.
SysLang=$( echo ${LANG} | cut -d= -f2 | cut -d. -f1 | sort -u )

if [[ -f ${INCLUDEDIR}/${0:t}/language/${MyLANG}.inc ]]; then
    include ${0:t}/language/${MyLANG} ${0:t}
    NOLANG=${SysLang}
elif [[ -f ${INCLUDEDIR}/${0:t}/language/${SysLang}.inc ]]; then
    include ${0:t}/language/${SysLang} ${0:t}
    NOLANG=${MyLANG}
else
    echo "\n${RED}Could not find a language file for your system language (${NOLANG}).${END}"
    echo "${WHITE}Would you like to continue with English (en_US)? (Y/n)${END} \c"
    read LangAnswer
    if [[ ( ${LangAnswer} == "" || ${LangAnswer} == "Y" || ${LangAnswer} == "y" ) ]]; then
        include ${0:t}/language/en_US ${0:t}
    else
        echo "\n${YELLOW}You decided not to continue. Sorry about that!${END}"
        echo "${WHITE}Please consider translating this script to your language.${END}"
        echo "${WHITE}The language files can be found at"
        echo "${INCLUDEDIR}/${0:t}/language/${END}.\n"
        exit
    fi
fi

function ShowHelp () {
	# Usage: ShowHelp ${0:t}
    for i in {10..28}
    do
        help=Help_${i}
        eval echo \$${help}
    done
	exit
}

# Initialze the array in the function WithToArray before use
# Options are: --with=clean,dirty,addons,no-git,force
WithToArray ${@}
for i in ${WithArray}
do
    include ${0:t}/${i}
done

# The default behavior is to do a clean,addons install
# Same as build.leia --with=clean,addons
if [[ ! ${@} ]]; then
	MSG="${L_100} --with=clean,addons"
	echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
	include ${0:t}/clean
	include ${0:t}/addons
elif [[ ${@} =~ "--with" ]]; then
# We default to doing a clean install if not --with=clean is set and if --with=dirty is not set
	if [[ ! ${CLEAN_IS_SET} && ! ${DIRTY_IS_SET} ]]; then
		MSG="${L_100} --with=clean"
		echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		include ${0:t}/clean
	fi

fi

# If the input is other that --help or --with, display the --help message and exit
# This should prevent anyone from doing something they didn't want to.
if [[ ${1} == "--help" ]]; then
	ShowHelp ${0:t}
	exit
fi

VKODI=Leia

# Edit this to install to another directory
PREFIX="/opt/${VKODI}"
#

KODI=${KODIDIR}/${VKODI}
YEAR=$(date +%Y)
ARROW="${W}-${END}${INFO}>${END}"

# This text needs to be added to the language files. Hardcoded for now...
if [[ ${CLEAN_IS_SET} && ${DIRTY_IS_SET} ]]; then
	echo "${W}**${END} ${RED}${L_101}${END} ${W}**${END}"
	echo "${W}**${END} ${RED}${L_102} \"${0:t} --help\" ${L_103}${END} \t${W}**${END}"
	echo "${W}**${END} ${RED}${L_25}${END} \t\t\t\t\t\t\t${W}**${END}"
	exit
fi

# Function: FETCH_KODI
function fetch_kodi () {
	if [[ ! -d ${KODI} ]]; then
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_104} ${L_81}${END} \c"
		read answer
		
		if [[ ${answer} == "" || ${answer} == "${L_82}" || ${answer} == "${L_83}" ]]; then
			builtin cd ${KODIDIR} > /dev/null 2>&1
			MSG=${L_112}
			echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			git clone -b master https://github.com/xbmc/xbmc ${VKODI} >> ${LOGGYLOGFILE} 2>&1
			echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${L_105} ${L_81}${END} \c"
			read binaryaddons
			
			if [[ ${binaryaddons} == "" || ${binaryaddons} == "${L_82}" || ${binaryaddons} == "${L_83}" ]]; then
				BINARY_ADDONS_INSTALL=1
			else
				echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${PURPLE}${L_106}${END}"
				BINARY_ADDONS_INSTALL=0
				ADDON_IS_SET=0
			fi
		else
			echo "\n ${ARROW} ${YELLOW}${L_107} ${KODI}${END}"
			echo "${ARROW} ${YELLOW}git clone https://github.com/xbmc/xbmc ${VKODI}${END}"
			echo "${ARROW} ${WARNING}${L_25}${END}"
			exit
		fi
	fi
# We need to set a variable here so that we know it's a fresh copy
FRESH_INSTALL=1
}

# Function: GIT_PULL
function git_pull () {
if [[ ! ${FRESH_INSTALL} ]]; then
	
  if [[ ${FORCE_IS_SET} ]]; then
      local YesForce
      YesForce=" (${L_24})"
  fi
	
	MSG="${L_20} ${VKODI}${YesForce}"
	echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
    
  if [[ ! ${NOGIT_IS_SET} ]]; then

	MSG="${L_21} ${VKODI} ${L_22}"
	echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}

	builtin cd ${KODI}
  git pull > /tmp/build.leia.gitpull 2>&1
    
    if [[ $( grep "Already up-to-date" /tmp/build.leia.gitpull ) ]]; then
			if [[ ${FORCE_IS_SET} ]]; then
				FORCED="${L_24}"
			else
				FORCED="${L_25}"
			fi
		
    MSG="${VKODI} ${L_23} ${FORCED}"
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
		loggy ${MSG}
		GITMSG="${VKODI} ${L_108}"
        
		if [[ ! ${FORCE_IS_SET} ]]; then
      GITMSG="${VKODI} ${L_109}"
			exit
		fi
	fi
fi

# Removing the temp git pull file
loggy "##############################################################"
cat /tmp/build.leia.gitpull >> ${LOGGYLOGFILE} > /dev/null 2>&1
rm -f /tmp/build.leia.gitpull > /dev/null 2>&1

fi
}

# Function: CLEAN_KODI
function clean_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if [[ ! ${GITMSG} ]] || [[ ! ${FAILED} ]]; then

    MSG="${L_30} ${KODINAMEVERSION}"
    loggy ${MSG}
  
	if [[ ! ${FRESH_INSTALL} ]]; then
		if [[ ${CLEAN_IS_SET} ]]; then
			MSG="${L_113}"
			echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			builtin cd ${KODI}
			rm -rf kodi-build > /dev/null 2>&1
			mkdir kodi-build > /dev/null 2>&1
		elif [[ ${DIRTY_IS_SET} ]]; then
			builtin cd ${KODI}/kodi-build
		fi
	fi
# End of the GITMSG check
fi

}

# Function: CONFIGURE_KODI
function configure_kodi () {

		if [[ ${FRESH_INSTALL} ]]; then
			builtin cd ${KODI}
			mkdir kodi-build > /dev/null 2>&1
			MSG="${L_31} ${VKODI} ${L_37}"
			echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}${FFMPEG}"
			loggy ${MSG}
      builtin cd ${KODI}/kodi-build
      cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} >> ${LOGGYLOGFILE} 2>&1
			loggy "###########################################################"
		else
			if [[ ${CLEAN_IS_SET} ]]; then
				MSG="${L_31} ${VKODI} ${L_38}"
				echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}${FFMPEG}"
				loggy ${MSG}
				builtin cd ${KODI}/kodi-build
				cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} >> ${LOGGYLOGFILE} 2>&1
			elif [[ ${DIRTY_IS_SET} ]]; then
				MSG="${L_20} ${VKODI} ${L_39}"
				echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}${FFMPEG}"
				loggy ${MSG}
				builtin cd ${KODI}/kodi-build
			fi
		fi

}

# Function: BUILD_KODI
function build_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if [[ ! ${GITMSG} ]] || [[ ! ${FAILED} ]]; then

    MSG="${L_30} ${KODINAMEVERSION}"
    loggy ${MSG}
		
    MSG="${L_33} ${VKODI}. ${L_34}"
    echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
    loggy ${MSG}
    cmake --build . -- VERBOSE=0 -s -j${NUMCPU} >> ${LOGGYLOGFILE} 2>&1

    if [[ ! -f ${KODI}/kodi-build/kodi.bin ]]; then
        MSG="${L_35} ${VKODI} ${L_36}"
        echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
        loggy ${MSG}
				FAILED="${L_110} ${VKODI} ${L_111}"
    fi

# End of the GITMSG check
fi

}

# Function: INSTALL_KODI
function install_kodi () {

  if [[ ! ${FAILED} ]]; then
        MSG="${L_90} ${PREFIX}"
        echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
        loggy ${MSG}
        builtin cd ${KODI}/kodi-build
        sudo make -s install >> ${LOGGYLOGFILE} 2>&1
	loggy "#########################################################"
  fi

}

# Function: INSTALL_ADDONS
function install_addons () {
	if [[ ${ADDON_IS_SET} || ${BINARY_ADDONS_INSTALL} ]]; then
		if [[ ! ${FAILED} ]]; then
			if [[ ${CLEAN_IS_SET} ]]; then
		    MSG="${L_91}"
		    echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		    loggy ${MSG}
				builtin cd ${KODI}
		    sudo make -s -C \
				tools/depends/target/binary-addons \
				distclean \
				> /dev/null 2>&1
			fi

		    MSG="${L_92}"
		    echo "${WHITE}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		    loggy ${MSG}
		    sudo make -s -j${NUMCPU} -C \
		    tools/depends/target/binary-addons \
		    PREFIX=${PREFIX} \
		    >> ${LOGGYLOGFILE} 2>&1
		fi
	else
		MSG="${L_93}"
		echo "${WHITE}[$(date +%T)]${END} ${ARROW} ${YELLOW}${MSG}${END}"
		loggy ${MSG}
	fi
}

# Here we run all of our functions in turn
fetch_kodi
git_pull
clean_kodi
configure_kodi
build_kodi
install_kodi
install_addons

echo "###################################################################" >> ${LOGGYLOGFILE}
echo "#             End of compilation for ${VKODI}                     #" >> ${LOGGYLOGFILE}
echo "###################################################################" >> ${LOGGYLOGFILE}
echo "${WHITE}[$(date +%T)]${END} ${YELLOW}${L_120}: ${PREFIX}/bin/kodi${END}"
echo "${WHITE}[$(date +%T)]${END} ${YELLOW}${L_121}: ${LOGGYLOGFILE}${END}"